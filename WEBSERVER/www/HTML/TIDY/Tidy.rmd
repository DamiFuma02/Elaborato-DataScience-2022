---
title: "TIDYING /DATASETS/"
author: "Damiano Fumagalli"
date: "`r Sys.Date()`"
output:
  html_document:
    css: "../../STYLES/Tidy.css"
---

```{r setup, include=FALSE}
library(dplyr)
library(tidyr)
library(stringr)
knitr::opts_chunk$set(echo = TRUE)
source("../IMPORT/importData.R")
```

# INDEX {#indice}

-   [AMAZON](#amazon)

-   [DISNEY](#disney)

-   [GROSS](#gross)

-   [MOVIELENS](#movielens)

-   [NETFLIX](#netflix)

-   [SEQUELS](#sequels)

-   [OSCARS](#oscars)

-   [TMDB](#tmdb)

-   [DATA SOURCE](../Presentazione.html#fonte-dei-dati)

-   [UPDATE-DATA](#update-data)

# [AMAZON](#indice) {#amazon}

::: openSubIndex
\>\>\>
:::

::: subindex
-   [MOVIE TYPE](#amaztypes)

-   [SEPARATION](#amazseparation)

-   [GENRES](#amazgenres)

-   [RATINGS](#amazratings)

-   [COUNTRIES](#amazcountries)

-   [DIRECTORS](#amazdirectors)
:::

### TYPES {#amaztypes}

```{r}
levels(factor(amazon$type))
```

-   siccome sono due i possibili valori, la colonna può essere sostituita con valori logici TRUE o FALSE

```{r}
# View(amazon)
spec(amazon)

amazon = amazon %>% filter(!is.na(type))  %>% select(-date_added,-description,-show_id)
colnames(amazon)[6] = "Year"
colnames(amazon)[9] = "Genres"

levels(factor(amazon$type))
# CREA UNA COLONNA "Movie" LOGICA 
amazon = amazon %>% mutate(Movie = (type=="Movie")) %>% select(-type)

head(amazon)
```

### SEPARATION {#amazseparation}

```{r}
amazonMovies = amazon %>% filter(Movie == TRUE)
# ".{N}$" seleziona gli ultimi N caratteri della stringa
# viene rimosso " min" da ogni campo duration
amazonMovies = amazonMovies %>% mutate(duration = strtoi(gsub(".{4}$","",duration))) %>% select(-Movie)
head(amazonMovies)



amazonShows = amazon %>% filter(Movie == FALSE)
# In Seasons vengono lasciati solo i primi 2 caratteri
amazonShows = amazonShows %>% mutate(Seasons = substr(duration,1,2)) %>% select(-duration,-Movie) %>% mutate(Seasons = strtoi(gsub(" ","",Seasons)))
# Se esiste un carattere " " viene rimosso
head(amazonShows)
```

### GENRES {#amazgenres}

```{r}
genres = vector(mode = "character")
for (i in 1:nrow(amazon)){
  gen = unlist(str_split(amazon$Genres[i],", "))
  # vengono selezionati solo i generi che NON sono presenti in genres
  gen = gen[!(gen %in% genres)]
  genres = append(genres, gen )
}
(amazGenres = levels(factor(genres)))
amazonGenres = data.frame(
  genreID = 1:length(amazGenres),
  genre = amazGenres
)
```

### RATINGS {#amazratings}

[USA Amazon Rating](https://www.primevideo.com/help/ref=atv_hp_nd_cnt?nodeId=GFGQU3WYEG6FSJFJ)

```{r}

amazonMovieRatings = levels(factor(amazonMovies$rating))
amazonTVRatings = levels(factor(amazonShows$rating))

amazonRatTypes = levels(factor(amazon$rating))
(amazonRatingTypes = data.frame(
  ratingID = 1:length(amazonRatTypes),
  rating = amazonRatTypes,
  Movie = (amazonRatTypes %in% amazonMovieRatings)
))
# la colonna Movie indicherà se il rating type appartiene alla categoria Film o TV Show


```

### COUNTRIES {#amazcountries}

```{r}
countries = vector(mode = "character")
for (i in 1:nrow(amazon)){
  countr = unlist(str_split(amazon$country[i],", "))
  countr = countr[!(countr %in% countries)]
  countries = append(countries,countr)
}

# sbagliato perchè alcuni film possiedono più countries
# amazon %>% group_by(country) %>% summarise(count = n())

amazCountr = levels(factor(countries))
(amazonCountries = data.frame(
  countryID = 1:length(amazCountr),
  country = amazCountr
))
```

### DIRECTORS {#amazdirectors}

```{r}
directors = vector(mode = "character")
for (i in 1:nrow(amazon)){
  dir = unlist(str_split(amazon$director[i],", "))
  dir = dir[!(dir %in% directors)]
  directors = append(directors,dir)
}
dirs = levels(factor(directors))
amazonDirectors = data.frame(
  dirID = 1:length(dirs),
  director = dirs
)
```

# [DISNEY](#indice) {#disney}

::: openSubIndex
\>\>\>
:::

::: subindex
-   [TYPES](#distypes)
-   [SEPARATION](#disseparation)
-   [DURATION](#disduration)
-   [GENRES](#disgenres)
-   [RATING](#disrating)
-   [COUNTRIES](#discountries)
:::

```{r}
# View(disney)
# Descrizione e Data di Aggiunta non necessarie
disney = disney %>% select(-description,-date_added)
colnames(disney)[7] = "Year"
colnames(disney)[10] = "Genres"
head(disney)
```

### TYPES {#distypes}

```{r}
levels(factor(disney$type))
```

-   siccome sono due i possibili valori, la colonna può essere sostituita con valori logici TRUE o FALSE

```{r}
# MODIFICA TYPE
disney = disney %>% mutate(Movie = (type == "Movie")) %>% select(-type)
head(disney)
```

### SEPARATION {#disseparation}

```{r}
disneyMovies = disney %>% filter(Movie == TRUE)
disneyShows = disney %>% filter(Movie == FALSE)
```

### DURATION {#disduration}

-   Il campo Duration va modificato per Film e Serie TV diversamente

```{r}

# rimuove " min" alla fine di ogni campo e trasforma in numero intero
disneyMovies = disneyMovies %>% mutate(duration = strtoi(gsub(".{4}$","",duration)))
head(disneyMovies)


# rimuove tutti i caratteri superflui in modo da salvare solo il numero delle stagioni
disneyShows = disneyShows %>% mutate(Seasons = substr(duration,1,2)) %>% select(-duration) %>% mutate(Seasons = strtoi(gsub(" ","",Seasons)))
# rimuove anche eventuali " " e trasforma in numero intero
head(disneyShows)

```

### GENRES {#disgenres}

```{r}
genres = vector(mode = "character")
for (i in 1:nrow(disney)){
  gen = unlist(str_split(disney$Genres[i],", "))
  gen = gen[!(gen %in% genres)]
  genres = append(genres,gen  )
}
(disGenre  = levels(factor(genres)))
disneyGenreTable = data.frame(
  genreID = 1:length(disGenre),
  genre = disGenre
)
```

### RATING {#disrating}

```{r}
(disRats = levels(factor(disney$rating)))
disneyRatingTypes = data.frame(
  ratingID = 1:length(disRats),
  rating = disRats
)
```

### COUNTRIES {#discountries}

```{r}
countries = vector(mode = "character")
for (i in 1:nrow(disney)){
  countr = unlist(str_split(disney$country[i],", "))
  countr = countr[!(countr %in% countries)]
  countries = append(countries,countr  )
}
(disCount = levels(factor(countries)))
disneyCountries = data.frame(
  countryID = 1:length(disCount),
  country = disCount
)
```

# [GROSS](#indice) {#gross}

::: openSubIndex
\>\>\>
:::

::: subindex
-   [SEPARATION TITLE-YEAR](#groseparation)

-   [RUNTIME](#groruntime)

-   [GENRES](#grogenres)

-   [RATING](#groratings)

-   [DISTRIBUTORS](#grodistributors)
:::

```{r}
# View(HighestGrossers)
# spec(HighestGrossers)
# Release_Date e Movie Info non sono necessari
HighestGrossers = HighestGrossers %>% filter(!is.na(`Movie Runtime`)) %>% select(-...1,-`Movie Info`,-`Release Date`,-`International Sales (in $)`,-`Domestic Sales (in $)`)
head(HighestGrossers)
```

### SEPARATION {#groseparation}

```{r}
# SEPARAZIONE TITLE YEAR
HighestGrossers = separate(HighestGrossers,Title,into = c("Title","Year"),sep = -5) %>% mutate(Title = gsub('.{2}$', '', Title)) %>% mutate(Year = strtoi(gsub('.{1}$', '', Year)))
head(HighestGrossers)
```

### RUNTIME {#groruntime}

```{r}
HighestGrossers$`Movie Runtime`[1]
```

-   Convertire la notazione da "x hr y min" a "x min"

```{r}
# DURATION
HighestGrossers = HighestGrossers  %>% separate(`Movie Runtime`,into = c("Hour","Min"),sep = " hr ")
# toglie " min" da ogni campo
HighestGrossers = HighestGrossers %>% mutate(Min = gsub(" min","",Min))

# HOUR e MIN SONO CHARACTER, PERCIò BISOGNA CONVERTIRE IN INTERO
HighestGrossers = HighestGrossers %>% mutate("Duration (mins)" = ifelse(!is.na(Min), strtoi( Min)+(strtoi(Hour)*60),strtoi(Hour)*60 )) %>% select(-Min, -Hour)


head(HighestGrossers)
colnames(HighestGrossers)[4] = "Gross"
```

### GENRES {#grogenres}

-   Rlang non è in grado di interpretare il dato come vettore
-   è necessario rimuovere le "[" "]" dal blocco note perchè il carattere "[" non viene riconosciuto dalle funzioni di Rlang

```{r}

HighestGrossers = HighestGrossers %>% mutate(Genre = gsub("'",'',Genre))


genres = vector(mode = "character")
for (i in 1:nrow(HighestGrossers)){
  gen = unlist(str_split(HighestGrossers$Genre[i],", "))
  gen = gen[!(gen %in% genres)]
  genres = append(genres, gen )
}
(grossGenre = levels(factor(genres)))
grossGenreTable = data.frame(
  genreID = 1:length(grossGenre),
  genre = grossGenre
)
```

### RATING {#groratings}

```{r}
levels(factor(HighestGrossers$License))
```

### DISTRIBUTORS {#grodistributors}

```{r}
grossDistr = levels(factor(HighestGrossers$Distributor))
(grossDistributors = data.frame(
  distrID = 1:length(grossDistr),
  distributor = grossDistr
))
```

# [MOVIELENS](#indice) {#movielens}

::: openSubIndex
\>\>\>
:::

::: subindex
-   [MOVIES](#movmovies)

    -   [GENRES](#movgenres)

-   [RATINGS](#movratings)

-   [USERS](#movusers)

    -   [GENDER](#movgender)
    -   [ZIPCODES](#zipcodes)
:::

-   modificare i separatori da "::" a ";" direttamente dal blocco note
-   per leggere correttamente il file è necessario usare read_delim( filePath , delim=";")

## MOVIES {#movmovies}

```{r}
head(movies)

# "Titolo (1945)"  --separate--> "Titolo (" , "1945)"  --gsub--> "Titolo" , "1945"

movies = separate(movies,Title,into = c("Title","Year"),sep = -5) %>% mutate(Title = gsub('.{2}$','',Title),Year = strtoi(gsub('.{1}$', '', Year)))

head(movies)

```

#### GENRES {#movgenres}

```{r}
# View(movies)

arr = vector(mode = "character")
for (i in 1:nrow(movies)){
  gen = unlist(strsplit(movies$Genres[i],"|",fixed = TRUE))
  gen = gen[!(gen %in% arr)]
  arr = append(arr, gen )
}
(movieLensGenreTable = data.frame(
 genreID = 1:length(levels(factor(arr))),
 genre = levels(factor(arr))
))
```

## RATINGS {#movratings}

```{r}
spec(ratings)
ratings = ratings %>% filter(!is.na(movieID) && !is.na(Rating)) %>% select(-Timestamp) 
head(ratings)
(votiAmmessi = levels(factor(ratings$Rating)))
```

## USERS {#movusers}

```{r}
spec(users)
colnames(users)[1] = "userID"
colnames(users)[5] = "zip"   # affinche coincida con uszips
users = users %>% filter(!is.na(Gender) && !is.na(Age)  && !is.na(zip))
```

#### GENDER {#movgender}

```{r}
levels(factor(users$Gender))
```

-   siccome sono due i possibili valori, la colonna può essere sostituita con valori logici TRUE o FALSE

```{r}
# MODIFICA
users = users %>% mutate(Male = (Gender == "M")) %>% select(-Gender)
head(users)
```

```{r}
(workTable = data.frame(
  workID = 0:20,
  workType = c("other","academic/educator","artist","clerical/admin","college/grad student","customer service","doctor/health care","executive/managerial","farmer","homemaker","K-12 student","lawyer","programmer","retired","sales/marketing","scientist","self-employed","technician/engineer","tradesman/craftsman","unemployed","writer")
))


(ageTable = data.frame(
  ageID = levels(factor(users$Age)),
  age = c("Under 18","18-24","25-34","35-44","45-49","50-55","Over 56")
))
```

## ZIPCODES {#zipcodes}

```{r}
uszips = uszips %>% select(lng,lat,zip,state_name,county_fips)
```

# [NETFLIX](#indice) {#netflix}

::: openSubIndex
\>\>\>
:::

::: subindex
-   [MOVIE TYPES](#nettypes)

-   [SEPARATION](#netseparation)

-   [GENRES](#netgenres)

-   [RATINGS](#netratings)

-   [COUNTRIES](#netcountries)
:::

```{r}
# View(netflix)
spec(netflix)
# Descrizione e Data di Aggiunta non necessarie
netflix = netflix %>% select(-date_added,-description)
colnames(netflix)[7] = "Year"
colnames(netflix)[10] = "Genres"
```

### TYPES {#nettypes}

```{r}
levels(factor(netflix$type))
```

-   siccome sono due i possibili valori, la colonna può essere sostituita con valori logici TRUE o FALSE

```{r}
# MODIFICA TYPE
netflix = netflix %>% mutate(Movie = (type == "Movie")) %>% select(-type,-show_id)
```

### SEPARATION {#netseparation}

```{r}
netflixMovies = netflix %>% filter(Movie == TRUE) %>% select(-Movie)
# MODIFICA AL CAMPO DURATION
netflixMovies = netflixMovies %>% mutate(duration = gsub(" min","",duration))


netflixShows = netflix %>% filter(Movie == FALSE) %>% select(-Movie)
# DURATION TO SEASONS
netflixShows = netflixShows %>% mutate(Seasons = substr(duration,1,2)) %>% mutate(Seasons = strtoi(gsub(" ","",Seasons))) %>% select(-duration)

```

### GENRES {#netgenres}

```{r}
genres = vector(mode = "character")
for (i in 1:nrow(netflix)){
  gen = unlist(str_split(netflix$Genres[i],", "))
  gen = gen[!(gen %in% genres)]
  genres = append(genres, gen )
}
netGenr = levels(factor(genres))
(netflixGenres = data.frame(
  genreID = 1:length(netGenr),
  genre = netGenr
))
```

### RATINGS {#netratings}

```{r}
netRat = levels(factor(netflix$rating))
(netflixRatingTypes = data.frame(
  ratingID = 1:length(netRat),
  rating = netRat
))
```

### COUNTRIES {#netcountries}

```{r}
countries = vector(mode = "character")
netCountr = netflix %>% filter(!is.na(country)) 

head(netCountr %>% filter(str_ends(country,",")))
netCountr = netCountr %>% mutate(country = 
                                   ifelse(str_ends(country,","),gsub(".{1}$","",country),country)
                                   ) %>% mutate(country = 
                                   ifelse(str_starts(country,","),substring(country,3),country)
                                   )
netCountr = netCountr %>% mutate(country = gsub(", ",",",country))

head(netCountr)
for (i in 1:nrow(netCountr)){
  countr = unlist(str_split(netCountr$country[i],","))
  countr = countr[!(countr %in% countries)]
  countries = append(countries, countr )
}
netCount = levels(factor(countries))
netflixCountries = data.frame(
  countryID = 1:length(netCount),
  country = netCount
)
head(netflixCountries)
```

# SEQUELS {#sequels}

```{r}
spec(sequels)
sequels = sequels %>% select(-`Release Date`,-Description,-URL)
```

```{r}
Series = levels(factor(sequels$`Movie Series`))
# Contiene tutte le Serie che possiedono dei sequels
length(Series)
```

### GENRES {#seqgenres}

```{r}
genres = vector(mode = "character")
sequels = sequels %>% filter(!is.na(Genres))
for (i in 1:nrow(sequels)){
  gen = unlist(str_split(sequels$Genres[i],", "))
  gen = gen[!(gen %in% genres)]
  genres = append(genres,gen)
}
(seqGen = levels(factor(genres)))
seqGenres = data.frame(
  genID = 1:length(seqGen),
  genre = seqGen
)

#View(MoviesCleaned)
```

# [OSCARS](#indice) {#oscars}

```{r}
spec(awards)
colnames(awards)[8] = "title"
```

### WINNER

```{r}
levels(factor(awards$winner))
awards = awards %>% mutate(winner = (winner == "VERO"))
#View(awards)
if (all(awards$year_ceremony == awards$year_film+1)){
  print("la cerimonia di un anno premia i fil dell'anno precedente")
  awards = awards %>% select(-year_ceremony)
}
awards %>% group_by(title) %>% summarise(nominees = n()) %>% arrange(desc(nominees))
View(awards)

```

### GENDER

```{r}
levels(factor(awards$gender))
awards = awards %>% mutate(gender = 
                             ifelse(str_starts(gender,"f"),
                                    gsub("f","F",gender),
                                    gender
                                    )
                             )
levels(factor(awards$gender))
```

-   Due valori possibili sostituibili con valori logici TRUE o FALSE

```{r}
awards = awards %>% mutate(Male = (gender == "Male")) %>% select(-gender)
head(awards %>% select(Male))
awards = awards %>% filter(!is.na(film))

```


# UPDATE DATA {#update-data}

I datasets sono stati riformati togliendo eventuali dati inutili alla ricerca.

### AMAZON

```{r}
filePath = "../../CLEAN_DATA/"  # www/CLEAN_DATA

(amazonPath = paste(filePath,"AMAZON/",sep=""))
colnames(amazon) = tolower(colnames(amazon))
write_csv(amazon,paste(amazonPath,"amazon.csv",sep="") )
colnames(amazonMovies)  = tolower(colnames(amazonMovies))
write_csv(amazonMovies,paste(amazonPath,"amazonMovies.csv",sep="")  )
colnames(amazonShows)  = tolower(colnames(amazonShows))
write_csv(amazonShows,paste(amazonPath,"amazonShows.csv",sep="")  )
write_csv(amazonGenres,paste(amazonPath,"amazonGenres.csv",sep="") )
write_csv(amazonRatingTypes,paste(amazonPath,"amazonRatingTypes.csv",sep="") )
write_csv(amazonCountries,paste(amazonPath,"amazonCountries.csv",sep="") )
write_csv(amazonDirectors,paste(amazonPath,"amazonDirectors.csv",sep="") )

```

### DISNEY

```{r}

(disneyPath = paste(filePath,"DISNEY/",sep=""))
colnames(disney) = tolower(colnames(disney))
write_csv(disney,paste(disneyPath,"disney.csv",sep="")  )
colnames(disneyMovies) = tolower(colnames(disneyMovies) )
write_csv(disneyMovies,paste(disneyPath,"disneyMovies.csv",sep="")  )
colnames(disneyShows) = tolower(colnames(disneyShows))
write_csv(disneyShows,paste(disneyPath,"disneyShows.csv",sep="")  )
write_csv(disneyGenreTable,paste(disneyPath,"disneyGenreTable.csv",sep="") )
write_csv(disneyRatingTypes,paste(disneyPath,"disneyRatingTypes.csv",sep="") )
write_csv(disneyCountries,paste(disneyPath,"disneyCountries.csv",sep="") )
```

### HIGH GROSS

```{r}
(grossPath = paste(filePath,"GROSS/",sep=""))
colnames(HighestGrossers) = tolower(colnames(HighestGrossers))
write_csv(HighestGrossers,paste(grossPath,"gross.csv",sep="")  )
write_csv(grossGenreTable,paste(grossPath,"grossGenreTable.csv",sep="") )
write_csv(grossDistributors,paste(grossPath,"grossDistributors.csv",sep="") )

```

### MOVIELENS

```{r}
(movielensPath = paste(filePath,"MOVIELENS/",sep=""))
colnames(movies) = tolower(colnames(movies))
write_csv(movies,paste(movielensPath,"movies.csv",sep="")  )
colnames(ratings) = tolower(colnames(ratings))
write_csv(ratings,paste(movielensPath,"ratings.csv",sep="")  )
colnames(users) = tolower(colnames(users))
write_csv(users,paste(movielensPath,"users.csv",sep="") )
write_csv(workTable,paste(movielensPath,"workTable.csv",sep="") )
write_csv(ageTable,paste(movielensPath,"ageTable.csv",sep="") )
write_csv(movieLensGenreTable,paste(movielensPath,"movieLensGenreTable.csv",sep="") )
write_csv(uszips,paste(movielensPath,"uszips.csv",sep="") )
```

### NETFLIX

```{r}
(netflixPath = paste(filePath,"NETFLIX/",sep=""))
colnames(netflix) = tolower(colnames(netflix))
write_csv(netflix,paste(netflixPath,"netflix.csv",sep="") )
colnames(netflixMovies) = tolower(colnames(netflixMovies))
write_csv(netflixMovies,paste(netflixPath,"netflixMovies.csv",sep="")  )
colnames(netflixShows) = tolower(colnames(netflixShows))
write_csv(netflixShows,paste(netflixPath,"netflixShows.csv",sep="") )
write_csv(netflixGenres,paste(netflixPath,"netflixGenres.csv",sep="") )
write_csv(netflixRatingTypes,paste(netflixPath,"netflixRatingTypes.csv",sep="") )
write_csv(netflixCountries,paste(netflixPath,"netflixCountries.csv",sep="") )

```

### OSCARS

```{r}
(oscarPath = paste(filePath,"OSCARS/",sep=""))
colnames(awards) = tolower(colnames(awards))
write_csv(awards,paste(oscarPath,"oscars.csv",sep="") )


```

### SEQUELS

```{r}
(sequelPath = paste(filePath,"SEQUELS/",sep=""))

write_delim(sequels,paste(sequelPath,"sequels.csv",sep=""),delim= ";"  )
write_csv(seqGenres,paste(sequelPath,"sequelGenres.csv",sep=""))


```


### SUBINDEX-CODE

```{js}
buttons = document.querySelectorAll(".openSubIndex")
for (let index = 0; index < buttons.length; index++) {
    buttons[index].addEventListener("click",()=>{
    buttons[index].parentElement.children[2].style.display = "inline"
    })
}
```

Questo codice aggiunge un evento di ascolto a tutti i pulsanti "\>\>\>" , responsabili dell'apertura dei relativi subIndex
